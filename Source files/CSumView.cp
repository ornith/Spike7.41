// =================================================================================//	CBigView.cp  					©1995-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <UDrawingState.h>#include <LString.h>#include <math.h>#include "endian.h"#include "SpikeConstants.h"#include "CSumWindow.h"#include "CSumView.h"//#include "CProgWindow.h"#include "CSpike6App.h"Float64 CSumView::sxmin=0;Float64 CSumView::symin=0;Float64 CSumView::sxmax=0;Float64 CSumView::symax=0;Float64 CSumView::sxscale=0;Float64 CSumView::syscale=0;SInt32 CSumView::sxwindmin=0;SInt32 CSumView::sywindmin=0;SInt32 CSumView::sxwindmax=0;SInt32 CSumView::sywindmax=0;// ---------------------------------------------------------------------------------//		¥ CSumView// ---------------------------------------------------------------------------------CSumView::CSumView(){;}// ---------------------------------------------------------------------------------//		¥ CSumView(SPaneInfo&, SViewInfo&)// ---------------------------------------------------------------------------------CSumView::CSumView(	const SPaneInfo	&inPaneInfo,	const SViewInfo &inViewInfo )		: LView( inPaneInfo, inViewInfo ){;}// ---------------------------------------------------------------------------------//		¥ CSumView(const CSumView&)// ---------------------------------------------------------------------------------CSumView::CSumView(	const CSumView	&inOriginal )		: LView( inOriginal ){;}// ---------------------------------------------------------------------------------//		¥ CSumView(LStream*)// ---------------------------------------------------------------------------------CSumView::CSumView(	LStream	*inStream )		: LView( inStream ){;}// ---------------------------------------------------------------------------------//		¥ ~CSumView// ---------------------------------------------------------------------------------CSumView::~CSumView(){}// ---------------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------------voidCSumView::DrawSelf(){LStr255 *str;if (CSpike6App::theWaves==nil){return;}if (CSpike6App::tRecord==nil){return;}// Set the font and size.TextFont( kFontIDGeneva );TextSize( 9 );//SInt32 xwindmax,xwindmin,ywindmax,ywindmin;SInt32 ccl,i;Float64 yscale, xscale=1;Rect theFrame;CalcLocalFrameRect( theFrame );::EraseRect(&theFrame);//set min and max. The .BIN file has -maxint as minimum and +maxint as maximum//the time axis starts at 1 and ends at 64mYmin=-32767;//mYmin=CSpike4App::sMaxMin;mYmax=32768;//mYmax=CSpike4App::sMaxPlus;StColorPenState::Normalize();		// Draw in black and whiteCalcLocalFrameRect(theFrame);//::FrameRect(&theFrame);//xwindmax = theFrame.right-5;SInt16 xoffset=15;//resize the imageSInt16 numcols=3, numrows=10;SInt16 rowheight=(SInt16)round((theFrame.bottom-theFrame.top)/numrows);SInt16 colwidth=(SInt16)round((theFrame.right-theFrame.left)/numcols);SInt16	plotwidth=64;//the length of the xaxes of bot the histogram and the waveplotSInt16 wavheight=(SInt16)round(0.64*rowheight);SInt16 rownum,colnum,myvar;CSpike6App::waveform wvfrm;CSpike6App::histo hist;CSpike6App::templrecrd trec;Float64 val;//draw waveforms firstyscale=CSumWindow::amp*wavheight/(2.0*32768.0);SInt32 sp,cnt=CSpike6App::theWaves->GetCount(), count=CSpike6App::theAvgs->GetCount();SInt32 hpos,vpos;if (cnt != 0){	if (CSumWindow::DrawAll){		for (sp=1; sp<=cnt; sp++){			CSpike6App::theWaves->FetchItemAt(sp,&wvfrm);			CSpike6App::tRecord->FetchItemAt(sp,&trec);			if(trec.templatenum==1){				myvar=1;				}			colnum=(SInt16)(trunc(((float)trec.templatenum-1)/(float)numrows));			val=((Float64)trec.templatenum/(Float64)numrows-colnum)*(float)numrows;			rownum=round(val);			colnum+=1;			hpos=xoffset+(colnum-1)*colwidth;			vpos=wavheight+rowheight*(rownum)-round(yscale*wvfrm.wavform[0]);			MoveTo(hpos,vpos);			for(i=0;i<=63;i++){				hpos+=1;				vpos=wavheight+rowheight*(rownum)-round(yscale*wvfrm.wavform[i]);				LineTo(hpos,vpos);				MoveTo(hpos,vpos);				}			}		}	else {		//draw averages only		for (sp=1;sp<=count;sp++){			CSpike6App::theAvgs->FetchItemAt(sp,&wvfrm);			colnum=(SInt16)(trunc((float)sp-1)/((float)numrows));			val=((Float64)sp/(Float64)numrows-colnum)*numrows;			rownum=round(val);			colnum+=1;			hpos=xoffset+(colnum-1)*colwidth;			vpos=wavheight+rowheight*(rownum)-round(yscale*wvfrm.wavform[0]);			MoveTo(hpos,vpos);			for(i=0;i<=63;i++){				hpos+=1;				vpos=wavheight+rowheight*(rownum)-round(yscale*wvfrm.wavform[i]);				LineTo(hpos,vpos);				MoveTo(hpos,vpos);				}			}		}	}//DrawCluster numbersTextFont( systemFont );for (i=0; i<=CSpike6App::snTemplates-1; i++){	colnum=(SInt16)(trunc(((float)i-1)/(float)numrows));	val=((Float64)i/(Float64)numrows-colnum)*(float)numrows;	rownum=round(val);	colnum+=1;	hpos=xoffset-13+(colnum-1)*colwidth;	vpos=wavheight+rowheight*(rownum-1);	MoveTo(hpos,vpos);	str=new LStr255(i-1);	DrawString(*str);	delete str;	str=nil;	hpos=xoffset+plotwidth+10+(colnum-1)*colwidth;	MoveTo(hpos,vpos);	CSpike6App::sAvgCol2->FetchItemAt(i,&cnt);	str=new LStr255(cnt);	DrawString(*str);	delete str;	}//end of plotting waves, cluster numbers and number of spikes in clusterTextFont( kFontIDGeneva );TextSize( 9 );SInt32 max;for (ccl=1;ccl<=CSpike6App::snTemplates;ccl++){	colnum=(SInt16)(trunc((ccl-1)/(float)numrows));	val=((Float64)ccl/(Float64)numrows-colnum)*(float)numrows;	rownum=round(val+1);	colnum+=1;	CSpike6App::theHistogram->FetchItemAt(ccl,&hist);	max=0;	for(i=0; i<=63;i++){		if(hist.histdata[i]>max){max=hist.histdata[i];}		}	if (max>0){		yscale = 45.0/max;		}	else {		yscale=1;		}	hpos=xoffset+135 + (colnum-1)*colwidth;	vpos=rowheight+(rownum-1)*rowheight-5;	MoveTo(hpos,vpos);	hpos=hpos+128;	LineTo(hpos,vpos);	hpos=xoffset+135 + (colnum-1)*colwidth;	MoveTo(hpos,vpos);	vpos=rowheight+(rownum-1)*rowheight-round(yscale*max)-5;	LineTo(hpos,vpos);	MoveTo(hpos-25,vpos+10);	if(max>0){		str=new LStr255(max);    	DrawString(*str);    	}	hpos=xoffset+135 + (colnum-1)*colwidth;	vpos=rowheight+(rownum-1)*rowheight-round(yscale*hist.histdata[0])-5;	MoveTo(hpos,vpos);	for(i=1;i<=63;i++){		hpos+=2;		LineTo(hpos,vpos);		vpos=rowheight+(rownum-1)*rowheight-round(yscale*hist.histdata[i])-5;		LineTo(hpos,vpos);		}	hpos+=2;	LineTo(hpos,vpos);	vpos=rowheight+(rownum-1)*rowheight-5;	LineTo(hpos,vpos);	}//xscale=(xwindmax-xwindmin)/(mXmax-mXmin);//yscale=(ywindmin-ywindmax)/(mYmax-mYmin);sxmin=mXmin;symin=mYmin;sxmax=mXmax;symax=mYmax;sxscale=xscale;syscale=yscale;/*sxwindmin=xwindmin;sywindmin=ywindmin;sxwindmax=xwindmax;sywindmax=ywindmax;*/}