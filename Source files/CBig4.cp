// =================================================================================//	CBigView.cp  					©1995-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <UDrawingState.h>#include "CBig4.h"#include <LString.h>#include "SpikeConstants.h"#include "CStatsWindow.h"Float64 CBig4::sxmin=0;Float64 CBig4::symin=0;Float64 CBig4::sxmax=0;Float64 CBig4::symax=0;Float64 CBig4::sxscale=0;Float64 CBig4::syscale=0;SInt32 CBig4::sxwindmin=0;SInt32 CBig4::sywindmin=0;SInt32 CBig4::sxwindmax=0;SInt32 CBig4::sywindmax=0;// ---------------------------------------------------------------------------------//		¥ CBig4// ---------------------------------------------------------------------------------CBig4::CBig4(){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CBig4(SPaneInfo&, SViewInfo&)// ---------------------------------------------------------------------------------CBig4::CBig4(	const SPaneInfo	&inPaneInfo,	const SViewInfo &inViewInfo )		: LView( inPaneInfo, inViewInfo ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CBig4(const CBig4&)// ---------------------------------------------------------------------------------CBig4::CBig4(	const CBig4	&inOriginal )		: LView( inOriginal ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CBig4(LStream*)// ---------------------------------------------------------------------------------CBig4::CBig4(	LStream	*inStream )		: LView( inStream ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ ~CBig4// ---------------------------------------------------------------------------------CBig4::~CBig4(){}// ---------------------------------------------------------------------------//	¥ ConstrainMouse												  [public]// ---------------------------------------------------------------------------//	Override to constrain the mouse within the frame of this viewvoidCBig4::ConstrainMouse(	const LMarqueeTask&	/* inMarqueeTask */,	Point&				ioMouseLocal,	UInt16				/* inModifiers */){	Rect	frame;	CalcLocalFrameRect(frame);		::InsetRect(&frame, 1, 1);	// Account for 1-pixel border which								//   we draw around the view			// We could use the Toolbox routine ::PinRect(), but		// that routine has a documented bug when the point is		// exactly on the lower right corner. So we do it ourself		// by testing each edge.		if (ioMouseLocal.h < frame.left) {		ioMouseLocal.h = frame.left;			} else if (ioMouseLocal.h > frame.right - 1) {		ioMouseLocal.h = frame.right - 1;	}		if (ioMouseLocal.v < frame.top) {		ioMouseLocal.v = frame.top;		} else if (ioMouseLocal.v > frame.bottom - 1) {		ioMouseLocal.v = frame.bottom - 1;	}}// ---------------------------------------------------------------------------//	¥ ClickSelf													   [protected]// ---------------------------------------------------------------------------voidCBig4::ClickSelf(	const SMouseDownEvent&	 inMouseDown){	FocusDraw();		if ( not ::EmptyRect(&mSelection) ) {		// Erase existing selection		::EraseRect(&mSelection);		mSelection = Rect_0000;		StopIdling();	}			// Create LMarquee object on the stack		LMarqueeTask theMarquee(*this, inMouseDown);			// DoMarquee() will handle all mouse tracking. Look at the		// LMarqueeReceiver class for details on which functions to		// override in order to provide visual feedback while tracking.		theMarquee.DoMarquee();			// Finished tracking. Ask the MarqueeTask what rectangle		// the user selected.		theMarquee.GetMarqueeRect(mSelection);		//now what does this mean in terms of x and y values?					// If the selection rectangle is really small, assume the		// user just clicked in the view. We'll interpret this to		// mean there is no selection.		if ( ((mSelection.right - mSelection.left) < 2) &&			((mSelection.bottom - mSelection.top < 2)) ) {		mSelection = Rect_0000;	}		Draw(nil);					// Draw now to frame the selection		StartIdling();				// Request idle time to animate selection}// ---------------------------------------------------------------------------//	¥ GetTargetView													  [public]// ---------------------------------------------------------------------------//	Required override for LMarqueeReceiverconst LView*CBig4::GetTargetView() const{	return this;}// ---------------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------------voidCBig4::DrawSelf(){	// Set the font and size.TextFont( kFontIDGeneva );TextSize( 9 );SInt32 xwindmax,xwindmin,ywindmax,ywindmin;SInt32 i,hpos,vpos,xoffset,yoffset;Float64 yscale, xscale, xx, yy, minx, maxx,miny,maxy;Rect kk;Rect theFrame;CalcLocalFrameRect( theFrame );::EraseRect(&theFrame);LArray *mArray1=nil;LArray *mArray2=nil;UInt32 cnt1=0;UInt32 cnt2=0;if (CStatsWindow::stDrawCol1 != nil){	mArray1=CStatsWindow::stDrawCol1a;	cnt1=mArray1->GetCount();	}if (CStatsWindow::stDrawCol2 != nil){	mArray2=CStatsWindow::stDrawCol2a;	cnt2=mArray2->GetCount();	}if (cnt1>cnt2){cnt1=cnt2;}// Calculate the frame rect (local coordinates).if ((mArray1 != nil) && (mArray2 != nil))	{		if (not ::EmptyRect(&mSelection)) {		// Frame selection with a		mMarchingAnts.UseAntsPattern();		//   marching ants pattern		::FrameRect(&mSelection);		mXmin=(mSelection.left-CBig4::sxwindmin)/CBig4::sxscale + CBig4::sxmin;		mXmax=(mSelection.right-CBig4::sxwindmin)/CBig4::sxscale + CBig4::sxmin;		mYmin=(CBig4::sywindmin-mSelection.bottom)/CBig4::syscale +CBig4::symin;		mYmax=(CBig4::sywindmin-mSelection.top)/CBig4::syscale +CBig4::symin;		if (mXmax>sxmax){mXmax=sxmax;}		if (mYmax>symax){mYmax=symax;}		if (mXmin<sxmin){mXmin=sxmin;}		if (mYmin<symin){mYmin=symin;}		mSelection = Rect_0000;		StopIdling();		}	else //find regular min and max.		{		minx=100000000;   		maxx=-100000000;    	miny=100000000;    	maxy=-100000000;    	for (i=1;i<= cnt1; i++)    		{    		mArray1->FetchItemAt(i, &xx);    		if (xx<minx) {minx=xx;}else if (xx>maxx) {maxx=xx;}    		mArray2->FetchItemAt(i, &yy);    		if (yy<miny) {miny=yy;}else if (yy>maxy) {maxy=yy;}    		}    	mXmin=minx;		mXmax=maxx;		mYmin=miny;		mYmax=maxy;    	}	StColorPenState::Normalize();		// Draw in black and white	//CalcLocalFrameRect(theFrame);	::EraseRect(&theFrame);	//::FrameRect(&theFrame);	if ((cnt1 != 0)&&(cnt2 != 0))		{		xwindmax = theFrame.right-15;		xoffset=40;		yoffset=30;		xwindmin = theFrame.left+xoffset;		ywindmin = theFrame.bottom-yoffset;		ywindmax = theFrame.top+10;    	::MoveTo(xwindmin,ywindmin);    	::LineTo(xwindmin,ywindmax);    	::MoveTo(xwindmin,ywindmin);    	::LineTo(xwindmax,ywindmin);    	//needs to be elaborated    	//get maximum and minimum plotvalues (are statics in CStatWindow)    	/*draw only when there is valid data*/    	if ((mXmax>mXmin)and(mYmax>mYmin))    		{    		xscale=(xwindmax-xwindmin)/(mXmax-mXmin);   			yscale=(ywindmin-ywindmax)/(mYmax-mYmin);   	 		//move to first datapoint    		mArray1->FetchItemAt(1,&xx);    		mArray2->FetchItemAt(1,&yy);    		hpos=xscale*(xx-mXmin)+xwindmin;    		vpos=ywindmin-yscale*(yy-mYmin);    		::MoveTo(hpos,vpos);    		for (i=2;i<=cnt1; i++)    			{    			mArray1->FetchItemAt(i,&xx);    			mArray2->FetchItemAt(i,&yy);    			hpos=xscale*(xx-mXmin)+xwindmin;    			vpos=ywindmin-yscale*(yy-mYmin);    			if (((hpos<=xwindmax)&&(hpos>=xwindmin))&&((vpos>=ywindmax)&&(vpos<=ywindmin)))					{    				::SetRect(&kk, hpos-1, vpos-1, hpos + 1, vpos + 1);					::FrameRect(&kk);    				//::LineTo(hpos,vpos);    				//::MoveTo(hpos,vpos);    				}    			}    		MoveTo(xwindmin-10,ywindmin+15);			LStr255 str(mXmin,"\p#####.#");    		DrawString(str);    		MoveTo(xwindmax-20,ywindmin+15);    		str.Assign(mXmax, "\p#####.#");    		DrawString(str);    		MoveTo(xwindmin-39,ywindmin+5);    		str.Assign(mYmin,"\p#####.#");    		DrawString(str);    		MoveTo(xwindmin-39,ywindmax+5);    		str.Assign(mYmax, "\p#####.#");    		DrawString(str);    		sxmin=mXmin;			symin=mYmin;			sxmax=mXmax;			symax=mYmax;			sxscale=xscale;			syscale=yscale;			sxwindmin=xwindmin;			sywindmin=ywindmin;			sxwindmax=xwindmax;			sywindmax=ywindmax;			}		}	}}// ---------------------------------------------------------------------------//	¥ SpendTime														  [public]// ---------------------------------------------------------------------------voidCBig4::SpendTime(	const EventRecord&	/*  inMacEvent */){		// Animate the selection if we are in an active window. Selection		// appears to animate because the LMarchingAnts class rotates the		// pen pattern each time we draw.	if ( not ::EmptyRect(&mSelection)  &&		 IsActive()  &&		 FocusExposed() ) {				StColorPenState::Normalize();			// Draw in black and white					// BeginMarch() returns true if we should draw now. If it returns			// false, it means that not enough time has passed since the last			// time we drew. 				if ( mMarchingAnts.BeginMarch() ) {						// At this point, LMarchingAnts has set the pen pattern to				// the ants pattern. Any subsequent QuickDraw calls will use				// this pattern to draw. This is most suitable for the				// various FrameXXX() QuickDraw functions.					::FrameRect(&mSelection);							// Now me must call EndMarch(), which rotates the ants				// pattern so that the next time we draw the "ants" will				// be in a different position.						mMarchingAnts.EndMarch();		}	}}