// =================================================================================//	CBigView.cp  					©1995-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <UDrawingState.h>#include "CBig4.h"#include <LString.h>#include <math.h>#include <LEditText.h>#include "endian.h"#include "SpikeConstants.h"#include "CStatsWindow.h"#include "CWavPlot.h"#include "CSpike6App.h"Float64 CWavPlot::sxmin=0;Float64 CWavPlot::symin=0;Float64 CWavPlot::sxmax=0;Float64 CWavPlot::symax=0;Float64 CWavPlot::sxscale=0;Float64 CWavPlot::syscale=0;SInt32 CWavPlot::sxwindmin=0;SInt32 CWavPlot::sywindmin=0;SInt32 CWavPlot::sxwindmax=0;SInt32 CWavPlot::sywindmax=0;// ---------------------------------------------------------------------------------//		¥ CWavPlot// ---------------------------------------------------------------------------------CWavPlot::CWavPlot(){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CWavPlot(SPaneInfo&, SViewInfo&)// ---------------------------------------------------------------------------------CWavPlot::CWavPlot(	const SPaneInfo	&inPaneInfo,	const SViewInfo &inViewInfo )		: LView( inPaneInfo, inViewInfo ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CWavPlot(const CWavPlot&)// ---------------------------------------------------------------------------------CWavPlot::CWavPlot(	const CWavPlot	&inOriginal )		: LView( inOriginal ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ CWavPlot(LStream*)// ---------------------------------------------------------------------------------CWavPlot::CWavPlot(	LStream	*inStream )		: LView( inStream ){mSelection = Rect_0000;}// ---------------------------------------------------------------------------------//		¥ ~CWavPlot// ---------------------------------------------------------------------------------CWavPlot::~CWavPlot(){}// ---------------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------------voidCWavPlot::DrawSelf(){	// Set the font and size.TextFont( kFontIDGeneva );TextSize( 9 );SInt32 xwindmax,xwindmin,ywindmax,ywindmin;SInt32 i,j,k, locc, lastspike,hpos,vpos,xoffset,yoffset;Float64 yscale, xscale, xx, yy;Rect theFrame;CalcLocalFrameRect( theFrame );::EraseRect(&theFrame);//set min and max. The .BIN file has -maxint as minimum and +maxint as maximum//the time axis starts at 1 and ends at 64mXmin=1;mXmax=64;//mYmin=-32768;mYmin=CSpike6App::sMaxMin;//mYmax=32767;mYmax=CSpike6App::sMaxPlus;StColorPenState::Normalize();		// Draw in black and whiteCalcLocalFrameRect(theFrame);::FrameRect(&theFrame);xwindmax = theFrame.right-15;xoffset=15;yoffset=15;xwindmin = theFrame.left+xoffset;ywindmin = theFrame.bottom-yoffset;ywindmax = theFrame.top+15;lastspike = CSpike6App::sWavs->GetCount();//get the binfile dataBoolean usearray=true;Handle theHandle;char *pntr;if(CSpike6App::theWaves!=nil){	usearray=true;}else {	usearray=false;	theHandle=CSpike6App::BinFile;	pntr=*theHandle;	}//FindOccurrences i.e. locations of spikesSInt32 wave[64],count=0,max,left,width,right;Float64 halfmax,avgwave[64];for (j=0;j<=63;j++){	wave[j]=0;    avgwave[j]=0;	}xx=1;xscale=(xwindmax-xwindmin)/(mXmax-mXmin);yscale=(ywindmin-ywindmax)/(mYmax-mYmin);    //Pattern	grayPat, blackPat, mypat;    //GetQDGlobalsLightGray(&mypat);    //UQDGlobals::GetGrayPat(&grayPat);	//PenPat(&mypat);if(usearray){    //::ForeColor (greenColor);	CSpike6App::waveform wvfrm;	for (j=1;j<=lastspike;j++)		{		count+=1;		CSpike6App::sWavs->FetchItemAt(j,&k);		CSpike6App::theWaves->FetchItemAt(k,&wvfrm);		hpos=xwindmin;		yy=wvfrm.wavform[0];		vpos=ywindmin-yscale*(yy-mYmin);		::MoveTo(hpos,vpos);		//move to first datapoint		for (i=0;i<=63; i++)   			{   			xx=i;  			  			yy=wvfrm.wavform[i];  			wave[i]+=yy;            avgwave[i]+=yy;//lastspike;   			vpos=ywindmin-yscale*(yy-mYmin);    		::LineTo(hpos,vpos);    		::MoveTo(hpos,vpos);            hpos=hpos+ 8;    		}    	}    max=0;    for(i=0;i<=63;i++){    	wave[i]=round(wave[i]/count);    	if(wave[i]>max){    		max=wave[i];    		left=i;    		}    	}    halfmax=0.5*max;    for(i=left;i<=63;i++){    	if(wave[i]<=halfmax){    		right=i;    		break;    		}    	}    for(i=left;i>=0;i--){    	if(wave[i]<=halfmax){    		left=i;    		break;    		}    	}    width=right-left-1;    		    }else {	CSpike6App::sWavs->FetchItemAt(j,&k);	locc=(k-1)*136;	hpos=xwindmin;	//move to first datapoint	for (i=0;i<=63; i++)   		{   		xx=i;  		hpos=hpos+2;  		yy=*(UInt16 *)(pntr  + i*2 + locc);  		yy=EndianS16_LtoB(yy);   		vpos=ywindmin-yscale*(yy-mYmin);		::LineTo(hpos,vpos);		::MoveTo(hpos,vpos);                	}	}::ForeColor (redColor);    ::PenSize(4,4);    //::SetLineWidth(2);    //::SetPortPenSize( ::GetWindowPort( mSuperView), 1 );hpos=xwindmin;yy=avgwave[i]/lastspike;vpos=ywindmin-yscale*(yy-mYmin);::MoveTo(hpos,vpos);for (i=0;i<=63; i++)    {        yy=avgwave[i]/lastspike;        vpos=ywindmin-yscale*(yy-mYmin);        ::LineTo(hpos,vpos);        ::MoveTo(hpos,vpos);        hpos=hpos+ 8;    }//give width at half-maximumMoveTo(xwindmax-30,ywindmax+20);Str255 str;NumToString(width,str); DrawString(str);//LStr255 str(width,"\p####.#");//LEditText *myWidth=dynamic_cast<LStaticText *>(LPane::FindPaneByID(2));//SetDescriptorForPaneID(2,str);sxmin=mXmin;symin=mYmin;sxmax=mXmax;symax=mYmax;sxscale=xscale;syscale=yscale;sxwindmin=xwindmin;sywindmin=ywindmin;sxwindmax=xwindmax;sywindmax=ywindmax;}